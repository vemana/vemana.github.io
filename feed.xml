<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://vemana.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://vemana.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-10-26T13:23:17+00:00</updated><id>https://vemana.github.io/feed.xml</id><title type="html">Vemana’s Space.</title><subtitle>This is Vemana&apos;s space. I write about Topics include Software Engineering, Math, Life and anything that catches my fancy! </subtitle><entry><title type="html">Software Testing: Can it be objective?</title><link href="https://vemana.github.io/blog/2023/testing-calculator/" rel="alternate" type="text/html" title="Software Testing: Can it be objective?"/><published>2023-10-20T15:00:00+00:00</published><updated>2023-10-20T15:00:00+00:00</updated><id>https://vemana.github.io/blog/2023/testing-calculator</id><content type="html" xml:base="https://vemana.github.io/blog/2023/testing-calculator/"><![CDATA[<h1 id="5-minute-summary">5 minute summary</h1> <p>For a calculator <code class="language-plaintext highlighter-rouge">evaluate</code> function:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{...}</span>
</code></pre></div></div> <p>operating on AST</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sealed</span> <span class="kd">interface</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="n">record</span> <span class="nf">Addition</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Division</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Number</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Variable</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>Don’t write it like this (let’s give it a name: <strong>Natural Impl</strong>):</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">variables</span><span class="o">.</span><span class="na">getVariableValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">+</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">*</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">/</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
  <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <p>Write it like this instead (let’s give it a name: <strong>Homomorphic impl</strong> for reasons explained later):</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Since the thrust of this post is testing, we'll not comment on </span>
<span class="c1">// 1. Efficiency. For example, boxing, varargs overheads here. </span>
<span class="c1">//    There are many ways to mitigate them.</span>
<span class="c1">// 2. Error handling. What if an Addition node has &gt; 2 children? Or dividing by 0? </span>
<span class="c1">//    Again, there are many options.</span>

<span class="kd">interface</span> <span class="nc">Operator</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="nf">invoke</span><span class="o">(</span><span class="kt">long</span><span class="o">...</span> <span class="n">children</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Evaluator</span> <span class="o">{</span>
  
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">PLUS</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">MULTIPLY</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">DIVIDE</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]/</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

  <span class="c1">// This is our evaluate function implementation</span>
  <span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
        <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="nf">operator</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">varMap</span><span class="o">.</span><span class="na">getVariableValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">PLUS</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">MULTIPLY</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">DIVIDE</span><span class="o">;</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Expression</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>and write the following tests:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// One basics test per Node (like Addition, Multiplication)
expect(7, "a", {a = 7}); // Variable
expect(9, 9, {});        // Number
expect(11, "1+10", {});  // Addition
expect(12, "3*4", {});   // Multiplication
expect(2, "4/2", {});    // Division

// One test per Corner case per Node
expect_failure("1/0", {});
</code></pre></div></div> <p>With a Homomorphic Impl, <strong>you can confidently skip complex tests</strong> - like those that use arg depths &gt; 1.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Complex tests (arg depth &gt; 1): can be skipped with homomorphic implementation
expect(203, "10*20+a", {a=3});
expect(18, "a*b+(3*2)", {a=3, b=4});
</code></pre></div></div> <h2 id="wait-what-is-a-homomorphic-impl">Wait, what is a Homomorphic Impl?</h2> <p>This code exploits the fact that the <code class="language-plaintext highlighter-rouge">evaluate</code> function is a <a href="https://en.wikipedia.org/wiki/Homomorphism">Homomorphism</a> to separate tree traversal from operator application. So, each node defines its <strong>Operator</strong> function (PLUS, MULTIPLY etc.) and there’s a separate evaluator that traverses the Expression tree and invokes the Operators. Contrast this with the <strong>Natural Impl</strong> where the traversal is intertwined with the Operator application. This sort of coupling doesn’t age well - see <a href="#why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl</a>.</p> <h2 id="why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl?</h2> <p>There are many benefits to exploiting homomorphism.</p> <ul> <li><strong>[Test minimalism]</strong> <ul> <li>Write a minimal number of tests.</li> <li>No need to write complex argument tests. We can prove rigorously that they are not needed; but it is ok to write one single test with a complex expression</li> </ul> </li> <li><strong>[Ageable code]</strong>. Homomorphic Impl ages well along many important dimensions of change <ul> <li>Introduce parallelism easily if required. Doing this with Natural Impl gets very messy very quick <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Showing only the changed parts.</span>

<span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span><span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">,</span> <span class="nc">StructuredTaskScope</span> <span class="n">scope</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">var</span> <span class="n">childResults</span> <span class="o">=</span> <span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)))</span>
                         <span class="o">.</span><span class="na">toList</span><span class="o">();</span>
  <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
  <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
      <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">childResults</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Future:</span><span class="o">:</span><span class="n">resultNow</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li>Homomorphic Impl has O(1) calls to <code class="language-plaintext highlighter-rouge">evaluate</code> but Natural Impl has O(Nodes) calls to <code class="language-plaintext highlighter-rouge">evaluate</code> <ul> <li>Here, to be exact, Homomorphic Impl has 2 calls to <code class="language-plaintext highlighter-rouge">evaluate</code> while Natural Impl has 6 of them (2 each for addition, multiplication, division operators)</li> <li>Reducing calls to the API surface is extremely useful. For example, consider changing the API signature to pass one more parameter. It requires 2 changes in Homomorphic Impl but 6 changes in Natural Impl. This adds up quickly when you have 20 Operators instead of 5.</li> </ul> </li> <li>Add new operators with ease <ul> <li>For example, it is trivial to add the SUBTRACTION operator</li> <li>Code remains easy to read even with 20 operators, while the Natural Impl starts becoming unwieldy at say 10</li> </ul> </li> <li>Handoffs to different owners are relatively straightforward to explain</li> </ul> </li> </ul> <h2 id="summary-of-the-summary">Summary of the summary!</h2> <p>There’s a class of functions called Homomorphisms that can be coded in a certain pattern - the Homomorphic Impl - which requires only a small number of tests to gain confidence. The pattern also ages well to many typical changes. Homomorphisms are VERY common if you know to look for them, but that’s an entirely different post.</p> <hr/> <h1 id="introduction">Introduction</h1> <p>All good quality Software has tests. But, there’s the age old question faced by every software engineer:</p> <ul> <li>How many tests should I write?</li> <li>What kind of tests should I write?</li> </ul> <p>These are good questions that elicit non-committal, <strong>it depends</strong> answers that ultimately don’t help either the author, the code reviewer or the next maintainer.</p> <h2 id="why-care-about-eliminating-test-subjectivity-and-minimizing-tests">Why care about eliminating test subjectivity and minimizing tests?</h2> <p>High quality automated tests are essential for high quality software. Tests determine iteration &amp; in turn product velocity. A lack of tests is a disaster in the making - any project of reasonable size grinds to a crawl without automated tests while their presence avoids <code class="language-plaintext highlighter-rouge">hostage to the code</code> situations. Rapid changes can be made &amp; rolled out with confidence.</p> <p>Test minimalism is important because a large number of tests (for e.g. to obtain code coverage) carries significant costs - presubmit times balloon, tests tend to get coupled with code &amp; changes to one piece of code breaks a large number of tests for no good reason.</p> <p>Test subjectivity - that is, what tests to write - hinders productivity. It causes code review debates, missing tests (because there’s no framework to think about them) which bite later, difficulty in understanding which new tests to write when changing code, challenges in handovers to a different owners among others.</p> <p>There are plenty of other concerns that are topics for other posts. For example, once you decide to write a test (logically), how to write it cleanly in a way that conveys the intent of the test to any new maintainer? Really the list is endless; one can barely scratch the surface of quality tests with a single post.</p> <blockquote class="block-warning"> <p>Perhaps the most important thing going for quality tests is this funnel: quality tests -&gt; higher productivity -&gt; less need to hire a ton -&gt; less need to reduce the hiring bar -&gt; maintain high revenue/employee -&gt; happier employees -&gt; growth for everyone.</p> </blockquote> <h2 id="in-this-post">In this post…</h2> <blockquote class="block-tip"> <p>In this post, I’ll demonstrate a class of problems &amp; a strategy of coding for which we CAN objectively write a minimal number of tests with confidence &amp; coverage.</p> </blockquote> <p>Testing is such a complex subject that it is likely not feasible to provide a general recommendation. At the same time, there are probably some problem domains which admit objective recommendations. In more than a decade of engineering experience, I am yet to encounter objective recommendations for what &amp; how many tests to write. It is not even clear if such recommendations exist. But, in this post I argue otherwise and make an object recommendation on a particular problem domain.</p> <p>One might ask: how feasible is it to have one objective recommendation per problem domain that admits? It is a whole lot better than the current mess of general recommendations which mean different things to different people. As a field, current best practices around tests seem ambigous and fresh thoughts with more objectivity are necessary.</p> <hr/> <h1 id="a-surprisingly-robust-strawman">A [surprisingly robust] strawman</h1> <p>How to approach a daunting, nebulous question like <code class="language-plaintext highlighter-rouge">What kind of tests should I write?</code>? Start by asking a simpler, almost strawman question, of course!</p> <blockquote class="block-warning"> <p><strong>A simpler, natural question to ask</strong>: What is the minimal number of tests one needs to write for a Calculator program?</p> </blockquote> <h2 id="making-the-question-concrete">Making the question concrete</h2> <p>Let’s make it concrete by defining an Expression AST. The Calculator program operates on this AST.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Calculator program Expression AST</span>

<span class="n">sealed</span> <span class="kd">interface</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="n">record</span> <span class="nf">Addition</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Division</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Number</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Variable</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>Some example <code class="language-plaintext highlighter-rouge">Expression</code>s include <code class="language-plaintext highlighter-rouge">(a*10+b)/100</code> which corresponds to a AST that looks like:</p> <ul> <li>Division <ul> <li>Addition <ul> <li>Multiplication <ul> <li>Variable(“a”)</li> <li>Number(10)</li> </ul> </li> <li>Variable(“b”)</li> </ul> </li> <li>Number(100)</li> </ul> </li> </ul> <p>So, now we are ready to restate the question.</p> <blockquote class="block-warning"> <p><strong>Concrete strawman question</strong>: How to write a Calculator program where:</p> <ul> <li>The program implements a function <code class="language-plaintext highlighter-rouge">long evaluate(Expression input, VariableMap variables);</code> that evaluates the expression</li> <li>The program should be accompanied by tests</li> <li>The tests should give confidence that the implementation works</li> <li>The number of tests should be minimal</li> </ul> </blockquote> <h2 id="solution-attempt">Solution Attempt</h2> <p>It is natural to write a solution that looks like this:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">variables</span><span class="o">.</span><span class="na">getVariableValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">+</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">*</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">/</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
  <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <p>And follow it up with tests like</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expect(11, "a+10", {a=1});
expect(12, "a*b", {a=3, b=4});
expect(203, "10*20+3", {});
</code></pre></div></div> <p>So far so good. But, the question remains: what tests to write &amp; how many of them to write. For example, are the following tests necessary?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. expect(18, "a*b+(3*2)", {a=3, b=4});
2. expect_failure("a/b", {a=1, b=0});
3. expect_failure(10 + 12/b, {b=0});
</code></pre></div></div> <p>Each of these tests ostensibly tests something. #1 appears to test a complex expression, #2 appears to test a corner case, #3 appears to combine them both (corner case within a complex expression). The challenge is to be able to objectively say that a given number of tests are sufficient.</p> <h2 id="segmenting-the-tests">Segmenting the tests</h2> <p>After some reflection, it is natural to arrive at a segmentation of tests:</p> <table> <thead> <tr> <th style="text-align: left">Test Id &amp; Description</th> <th style="text-align: left">Examples <br/> Format: <strong>Test Name: Example</strong></th> <th style="text-align: left">Count</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"><strong>[Per-node basic]</strong>. <br/> One basics test per Node type. The arguments have depth 1. <br/> Node can be Addition, Variable, Multiplication, Number, Division</td> <td style="text-align: left">Addition basic: <code class="language-plaintext highlighter-rouge">expect(11, 10+1, {})</code> <br/>Multiplication basic: <code class="language-plaintext highlighter-rouge">expect(20, 10*2, {})</code></td> <td style="text-align: left">O(#Nodes)</td> </tr> <tr> <td style="text-align: left"><strong>[Per-node corner case]</strong>. <br/> One test per corner case per node.</td> <td style="text-align: left">Division corner case: <code class="language-plaintext highlighter-rouge">expect_failure("1/0",{})</code></td> <td style="text-align: left">O(#Nodes)</td> </tr> <tr> <td style="text-align: left"><strong>[Complex arguments]</strong>. <br/> One test involving a complex expression, potentially involving all the operators</td> <td style="text-align: left">Complex arguments: <code class="language-plaintext highlighter-rouge">expect(5, 1*2+9/a, {a=3})</code></td> <td style="text-align: left">O(1), but unclear whether &amp; which ones to write</td> </tr> <tr> <td style="text-align: left"><strong>[Per-node Complex arguments]</strong>. <br/> One complex expression test per Node type</td> <td style="text-align: left">Addition complex arguments: <code class="language-plaintext highlighter-rouge">expect(22, 1*2+10*(1*2), {})</code> <br/> Multiplication complex arguments: <code class="language-plaintext highlighter-rouge">expect(15, (1+2)*(2+3), {})</code></td> <td style="text-align: left">O(#Nodes). Unclear whether to writes and if so, which ones to write</td> </tr> <tr> <td style="text-align: left"><strong>[Per-node Complex arguments arg depth = K]</strong>. <br/> One complex arguments test per Node type. At least one of the arguments has a depth K.</td> <td style="text-align: left">Addition complex arguments, arg depth=3: <code class="language-plaintext highlighter-rouge">expect(29, 1*2*3*4 + 5, {})</code></td> <td style="text-align: left">O(#Nodes). Unclear whether such tests should be written &amp; if so, what arg-depths are acceptable</td> </tr> </tbody> </table> <p><br/> In practice, different styles differ on whether to write <strong>[Per-node Complex arguments]</strong> test and what values of <code class="language-plaintext highlighter-rouge">K</code> are considered acceptable for <strong>[Per-node complex arguments, arg depth=K]</strong> tests.</p> <h2 id="this-strawman-is-robust">This strawman is robust!</h2> <p>Even this simple example of a Calculator demonstrates the inherent difficulty in deciding which tests to write.</p> <ul> <li>Without a meaningful segmentation of tests, we cannot answer whether there’s sufficient coverage and obtain confidence in the implementation.</li> <li>Even with a segmentation, it is unclear which test to write for each segment</li> </ul> <p>Segmentation is reasonable progress but we still haven’t answered which tests to write and why those tests give us confidence in the implementation.</p> <h2 id="skip-complex-argument-tests">Skip complex argument tests?</h2> <p>One might argue that complex arguments tests are not required because the code is recursively evaluating each child first and only passing its result to the parent operator. So, the complexity of the child argument is immaterial. This is certainly a reasonable argument &amp; in fact, one this post will make towards the conclusion. But, there are some important reasons to continue investigating further:</p> <ul> <li>[Special code structure] The testing strategy of skipping complex arguments is only valid when child evaluation results are passed to the parent <ul> <li>When a code base is touched by many people, this requirement can easily get lost</li> <li>Often, at the point when the original author moves on, the code has this structure but no one else knows that it has that structure</li> </ul> </li> <li>[Node complexity and cardinality] Even if all the code base authors are familiar with the code structure, a large number of node types and/or complex node evaluations can make it hard to maintain the structure <ul> <li>In the above example, we had 5 node types. In industrial strength applications - for e.g. translating a user query to sql - this factor can be more than 20</li> <li>Once we get above a few pages worth of the <code class="language-plaintext highlighter-rouge">evaluate</code> function, we’ll need tools to help ensure that we are always evaluating the children recursively before applying the parent’s operator</li> </ul> </li> </ul> <p>If only we had some tools to help us maintain the structure! Then, we can simply skip the complex argument tests with confidence.</p> <hr/> <h1 id="slaying-the-strawman">Slaying the strawman</h1> <p>How do we make progress? The primary cause of test subjectivity is the arg-depth of complex argument tests. We don’t know if a particular bug will be triggered only on arg depths of &gt;= 2 and in a particular traversal path through the Expression tree. So, it is reasonable to never fully feel confident that our code works for all possible depths while only testing a sample of depth 2.</p> <h2 id="dealing-with-arg-depth">Dealing with arg depth</h2> <blockquote> <p>One way to grapple with the arg depth question is to somehow make the arg depth immaterial i.e. complex argument tests will catch the same bugs regardless of arg depth.</p> </blockquote> <p>Let’s assume we can make arg-depth immaterial. What does it buy us? For a start, we can simply pick arg depth = 1. <code class="language-plaintext highlighter-rouge">Once we set arg depth = 1, [Per-node complex arguments arg depth = 1] is the same set of tests as [Per-node basic] tests. Remarkably, we can drop the complex argument tests w/o missing any coverage!</code> This is a sizeable reduction in the set of tests and contributes to the goal of reducing the number of tests.</p> <p>That’s promising. How do we make arg-depth immaterial? arg depth being immaterial means that the bugs found from arbitrary depths (ignore stack overflow) are the same bugs found at arg depth = 1. This suggests that the implementation function for a Node should not even have access to the child Nodes - if it did, the impl can become intricately dependent on the exact arg and a bug might be triggered on only a very specific tree <code class="language-plaintext highlighter-rouge">(Addition(Multiplication(Division)))</code> say and we wouldn’t know to test this particular tree. That is a bummer because <code class="language-plaintext highlighter-rouge">how can we implement the function if it can't even access the child Nodes?</code></p> <p>Perhaps surprisingly, there is a way to approach this. But first we need a detour in homomorphisms.</p> <h2 id="homomorphisms">Homomorphisms</h2> <p><a href="https://en.wikipedia.org/wiki/Homomorphism">Homomorphism</a> is an algebraic construct which essentially captures the following idea:</p> <blockquote class="block-tip"> <p><strong>Homomorphism in layman terms</strong> <br/> <br/></p> <p>Consider a function which evaluates Nodes in a Tree (or directed acyclic graph more generally)</p> <ul> <li>Example: functions like those in the strawman question: <code class="language-plaintext highlighter-rouge">long evaluate(Expression node, VariableMap vars)</code></li> <li>Such a function is either a homomorphism or not.</li> </ul> <p>It is a homomorphism if it has the following characteristics (to a good approximation)</p> <ul> <li>Each Node has a bunch of [possibly empty] child Nodes <ul> <li>Example: <code class="language-plaintext highlighter-rouge">Addition</code> Node has two children while <code class="language-plaintext highlighter-rouge">Number</code> Node has no children</li> </ul> </li> <li>Each Node type has a corresponding operator function <ul> <li>E.g. <code class="language-plaintext highlighter-rouge">SUM</code> is the operator function for <code class="language-plaintext highlighter-rouge">Addition</code> node, and <code class="language-plaintext highlighter-rouge">MULTIPLY</code> is the operator function for <code class="language-plaintext highlighter-rouge">Multiplication</code> node</li> <li>Note that this operator function cannot depend on the Node’s children. That is, Addition node will always have the same operator (<code class="language-plaintext highlighter-rouge">SUM</code>) regardless of its arguments.</li> <li>The operator function for a Node <code class="language-plaintext highlighter-rouge">Number(v)</code> is the zero-ary operator <code class="language-plaintext highlighter-rouge">v</code>; i.e. it’s a function which takes no arguments and always returns <code class="language-plaintext highlighter-rouge">v</code>. This is in contrast to the binary <code class="language-plaintext highlighter-rouge">SUM</code> function. In both cases, the Operator function is independent of children. Note that <code class="language-plaintext highlighter-rouge">v</code> is not a child of <code class="language-plaintext highlighter-rouge">Number(v)</code>, it is a configuration parameter, if you will.</li> </ul> </li> <li>The function’s evaluation of a Node is equivalent to applying the node’s operator function to the evaluated values of each of its children <ul> <li>That is, <code class="language-plaintext highlighter-rouge">Evaluate(Node(node params, child1, child2, ...)) := Node.operator(node params)(Evaluate(child1, child2, ..))</code></li> <li>That is, <code class="language-plaintext highlighter-rouge">Evaluate(Addition(left, right)) := SUM(Evaluate(left), Evaluate(right))</code></li> <li>Similarly, <code class="language-plaintext highlighter-rouge">Evaluate(Number(value)) := value() == value</code></li> </ul> </li> </ul> </blockquote> <h2 id="exploiting-homomorphisms">Exploiting Homomorphisms</h2> <p>Let’s start by noting that our Calculator’s <code class="language-plaintext highlighter-rouge">evaluate</code> function is a homomorphism.</p> <p>So what, you ask? Why do we care about Homomorphisms?</p> <ul> <li>Homomorphism has so much structure that it can be factored further</li> <li>Further factoring means we get to invoke one of the foundational principles of software engineering: separation of concerns</li> <li>The factors (aka concerns) are relatively straightforward too <ul> <li>Evaluating child Nodes</li> <li>Invoking the Node’s operator passing child node values as arguments</li> </ul> </li> <li>We can structure our code into two orthogonal pieces, one for each of the factors <ul> <li>Tests can be written for each of those orthogonal pieces</li> </ul> </li> </ul> <p><strong>Code structure after separating the factors: Evaluating child nodes &amp; Invoking node operators</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Since the thrust of this post is testing, we'll not comment on </span>
<span class="c1">// 1. Efficiency. For example, boxing, varargs overheads here. </span>
<span class="c1">//    There are many ways to mitigate them.</span>
<span class="c1">// 2. Error handling. What if an Addition node has &gt; 2 children? Or dividing by 0? </span>
<span class="c1">//    Again, there are many options.</span>

<span class="kd">interface</span> <span class="nc">Operator</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="nf">invoke</span><span class="o">(</span><span class="kt">long</span><span class="o">...</span> <span class="n">children</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Evaluator</span> <span class="o">{</span>
  
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">PLUS</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">MULTIPLY</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">DIVIDE</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]/</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

  <span class="c1">// This is our evaluate function implementation</span>
  <span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
        <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="nf">operator</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">varMap</span><span class="o">.</span><span class="na">getVariableValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">PLUS</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">MULTIPLY</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">DIVIDE</span><span class="o">;</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="kd">static</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Expression</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><br/></p> <p>With this structure, let’s examine the tests again</p> <ul> <li><strong>Per-node basic</strong> tests are required</li> <li><strong>Per-node corner case</strong> tests are required</li> <li>All other tests (e.g. complex arguments) can be skipped</li> </ul> <p>In particular, all other complex argument tests can be skipped. This is because composition is triggered even for the simplest evaluations. At this point, it is reasonable to ask: is this additional code worth it? isn’t it the same thing as the original attempt - just that the code is inline? Isn’t the original attempt more compact &amp; readable? All of these are legitimate questions that are answered in <a href="#why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl</a>.</p> <h1 id="conclusion">Conclusion</h1> <p>See <a href="#summary-of-the-summary">Summary of the Summary</a>.</p>]]></content><author><name></name></author><category term="software-engineering"/><category term="software-testing"/><summary type="html"><![CDATA[How many tests to write? What tests to write? Can there be objective answers? Surprisingly, the answer is yes for a certain class of programs.]]></summary></entry><entry><title type="html">What is Money? Where does it come from? An answer from symmetry.</title><link href="https://vemana.github.io/blog/2023/money-from-symmetry/" rel="alternate" type="text/html" title="What is Money? Where does it come from? An answer from symmetry."/><published>2023-10-19T15:00:00+00:00</published><updated>2023-10-19T15:00:00+00:00</updated><id>https://vemana.github.io/blog/2023/money-from-symmetry</id><content type="html" xml:base="https://vemana.github.io/blog/2023/money-from-symmetry/"><![CDATA[<h1 id="introduction">Introduction</h1> <p>Ever wondered what money is and where it comes from?</p> <ul> <li>This question bugged me for years until symmetry came to the rescue</li> <li>This post chronicles the thought process behind arriving at a satisfactory answer</li> <li>The secret lay in posing a simpler, concrete question and attempting to answer it</li> </ul> <hr/> <h1 id="a-strawman-that-wasnt">A strawman that wasn’t</h1> <p>How to answer a daunting, nebulous question like <em>what is money?</em></p> <ul> <li>It helps to ask a simpler, concrete question and try to answer it</li> <li>My concrete question was <blockquote class="block-warning"> <p>What happens when the bank lends John Doe money for a mortgage?</p> </blockquote> </li> <li>This question turned out to be both deceptively difficult and incredibly insightful.</li> </ul> <p>If you poll a few people, arguments often proceed like this:</p> <table> <thead> <tr> <th style="text-align: left">Argument</th> <th style="text-align: left">Counter argument</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"> </td> <td style="text-align: left">What happens when the bank lends money to John Doe for a mortgage?</td> </tr> <tr> <td style="text-align: left">The bank has money and gave it to John in exchange for interest payments.</td> <td style="text-align: left">Where did the bank get that money?</td> </tr> <tr> <td style="text-align: left">Why, it came from deposits like salaries</td> <td style="text-align: left">Where did the money for salaries come from?</td> </tr> <tr> <td style="text-align: left">Why, that comes from company revenues</td> <td style="text-align: left">Where did the company get those revenues from?</td> </tr> <tr> <td style="text-align: left">Why, that comes from consumers</td> <td style="text-align: left">Where did consumers get that money from?</td> </tr> <tr> <td style="text-align: left">Why, that comes from company revenues</td> <td style="text-align: left">See the circularity?</td> </tr> <tr> <td style="text-align: left">What’s the problem? Circularity is fine</td> <td style="text-align: left">Circularity cannot explain the origin of the ‘first’ money.</td> </tr> <tr> <td style="text-align: left">So?</td> <td style="text-align: left">This explanation is unsatisfactory..</td> </tr> <tr> <td style="text-align: left">You overthink things..</td> <td style="text-align: left">Uhh? No. I don’t accept unsatisfactory explanations</td> </tr> </tbody> </table> <p>I am not willing to accept that somehow this circularity works itself out; for one thing it doesn’t explain the origin of the ‘first’ money. So, there has to be a better explanation.</p> <hr/> <h2 id="breaking-circularity-using-symmetry">Breaking circularity using Symmetry</h2> <p>The root of the circular argument appears to be the asymmetric nature of the mortgage transaction. Pay attention to how we describe it: <code class="language-plaintext highlighter-rouge">The bank gave John money</code>. This is an <a href="https://en.wikipedia.org/wiki/Asymmetric_relation">asymmetric relation</a> because if we swap the bank and John, the statement would no longer be true <code class="language-plaintext highlighter-rouge">John gave the bank money</code>.</p> <p>This observation prompts the key question:</p> <blockquote class="block-warning"> <p>How can we describe the mortgage transaction as a Symmetric relationship; that is, if we swap the Bank and John, the description should still be true ?</p> </blockquote> <p>My first attempt at answering this also turned out to be insightful.</p> <blockquote class="block-tip"> <p>The bank and John enter a contract. Alternatively, John and the Bank owe each other something. <br/> <br/> Note how the statement is symmetric. Swapping bank and John in the statement doesn’t change it!</p> </blockquote> <p>That’s symmetric alright. But, what do they owe each other? This line of inquiry proved productive.</p> <hr/> <h2 id="liabilities-contracts-and-assets">Liabilities, Contracts and Assets</h2> <p>The symmetric answer can be simply restated as: <strong>In any transaction like the mortgage, the two parties are exchanging obligations.</strong>.</p> <p>Upon some reflection, we can arrive at the following insights, which we’ll explore in this section:</p> <ul> <li>Everyone can create/make a promise aka obligation <ul> <li>Liability is just another name for this promise</li> <li>Liability is the most primitive economic unit in any society. It costs nothing to make a promise - the trouble is finding someone to accept your promise!</li> </ul> </li> <li>Two parties can decide to accept each other’s Liability <ul> <li>This exchange of liabilities is a Contract</li> <li>Economy runs on Contracts</li> </ul> </li> <li>One party’s liability is the other party’s asset <ul> <li>All your assets are somebody’s liabilities!</li> <li>This may be surprising, but it really is so! Some liabilities have such low performance risk we don’t even contemplate non-performance</li> </ul> </li> </ul> <hr/> <h3 id="common-liabilities">Common Liabilities</h3> <p>With this in mind, we are ready to probe some standard liabilities we encounter. For each liability, we should be able to ask:</p> <ul> <li>Who is the liability issuer?</li> <li>What does that liability promise?</li> <li>Is there a risk of non-performance?</li> </ul> <table> <thead> <tr> <th style="text-align: left">Liability</th> <th style="text-align: left">Issuer</th> <th style="text-align: left">Liability of the issuer</th> <th style="text-align: left">Non-performance Risk</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">US Govt. bond</td> <td style="text-align: left">US Treasury</td> <td style="text-align: left">A US Govt. bond pays interest &amp; principal to the holder at a pre-determined schedule</td> <td style="text-align: left">Missed payments and/or principal.</td> </tr> <tr> <td style="text-align: left">US Dollar</td> <td style="text-align: left">Federal Reserve (Fed)</td> <td style="text-align: left">If you present 10$, Fed promises to give you 2x5$ (as funny as it sounds). The other implicit obligation is that the US Govt. accepts it as legal tender for tax payments. So, in that sense, it is a co-liability between the Fed &amp; the Treasury. Other than that, there’s nothing that the Fed promises on its US$ liability to a good approximation. They can print more of it with relatively little interference.</td> <td style="text-align: left">The Fed itself can always perform (exchanging 10$ for 2x5$), but US Treasury may accept a competing legal tender, can abolish taxes reducing need for US$ etc</td> </tr> <tr> <td style="text-align: left">Apple Stock</td> <td style="text-align: left">Apple Corporation</td> <td style="text-align: left">Apple corp promises to share dividends equally across all equity holders &amp; guarantees equal voting rights. Note: There’s no promise that any dividends will be paid - it only legally guarantees equal share in dividends and voting.</td> <td style="text-align: left">Unlikely, but legal changes may allow Apple Corporation to discrimnate between equity holders, preferentially paying dividends to only a few, for e.g.</td> </tr> <tr> <td style="text-align: left">Apple Corporate Bond</td> <td style="text-align: left">Apple Corporation</td> <td style="text-align: left">Similar to any bond: Apple Corp promises to pay interest &amp; principal at a predetermined schedule.</td> <td style="text-align: left">Missed payments and/or principal</td> </tr> <tr> <td style="text-align: left">Chair</td> <td style="text-align: left">Chair manufacturer</td> <td style="text-align: left">The chair allows you to sit on it for some number of years.</td> <td style="text-align: left">Chair doesn’t work as advertised or breaks down quickly etc.</td> </tr> <tr> <td style="text-align: left">Gold</td> <td style="text-align: left">Mother nature</td> <td style="text-align: left">It’s chemical properties of conductivity &amp; inertness will be maintained through millennia; new Gold can only be synthesised in supernovae, etc. There’s no guarantee from mother nature that Gold will be valued at a certain US$ price or higher over time. That is a human group-think phenomenon.</td> <td style="text-align: left">This is a tricky one. Gold’s properties are not directly guaranteed by mother nature (we can’t sue her!), but reflect our current understanding. It is entirely possible that humans misunderstood mother nature and discover later on that Gold has a half life and /or can be synthesized in lab, both of which will erode some of its important properties</td> </tr> <tr> <td style="text-align: left">Bitcoin</td> <td style="text-align: left">Bitcoin Network</td> <td style="text-align: left">A mined bitcoin will be perpetually verifiable and new bitcoins will only be issued using an algorithm.</td> <td style="text-align: left">Similar to gold, there’s no party to sue. It is entirely possible that the mining network suffers a Byzantine attack.</td> </tr> <tr> <td style="text-align: left">Laws of Physics</td> <td style="text-align: left">Mother nature</td> <td style="text-align: left">The Laws of physics work similarly everywhere</td> <td style="text-align: left">It is possible that humans understand some laws incorrectly; that is a human fault not really mother nature’s. But this is also a sort of co-liability: humans try to understand mother nature’s rules with the expectation that such rules indeed exist.</td> </tr> <tr> <td style="text-align: left">Checking account at JPM</td> <td style="text-align: left">JP Morgan Bank</td> <td style="text-align: left">On demand, you can withdraw US$ upto your account limit</td> <td style="text-align: left">JPM does not let you withdraw US$ on demand</td> </tr> <tr> <td style="text-align: left">Checking account at BofA</td> <td style="text-align: left">BofA</td> <td style="text-align: left">On demand, you can withdraw US$ upto your account limit</td> <td style="text-align: left">BofA does not let you withdraw US$ on demand</td> </tr> </tbody> </table> <blockquote class="block-warning"> <p><strong>Note</strong>: US$ is still Fed’s liability. JPM cannot print it. So, when John Doe withdraws US$ from a checking account, JPM has to fetch the US$ from the Fed to give it to John Doe. JPM’s checking account merely promises that on-demand it will be able to obtain those US$. It is entirely possible that JPM fails to honor this promise. So, 100$ in JPM checking account is not the same thing as 100$ in BofA checking account. All you have in the checking account is the respective banks’ promises and NOT US$.</p> </blockquote> <blockquote class="block-warning"> <p><strong>Note</strong>: ALL liabilities carry a non-performance risk. In some cases like a Chair or a Checking Account, it is easy to imagine non-performance. In other cases like US$, it is harder to imagine, but a non-performance risk absolutely exists.</p> </blockquote> <p>We colloquially say <strong>printing</strong> when an Issuer issues liabilities. For example, Apple can print more stock and dilute existing stock. Similarly, the Fed can print more US$ and dilute the existing US$.</p> <hr/> <h3 id="contracts-exchange-of-liabilities">Contracts: Exchange of Liabilities</h3> <p>Contracts are just an exchange of liabilities. Typically there are two parties. Some examples to illustrate.</p> <table> <thead> <tr> <th style="text-align: left">Contract</th> <th style="text-align: left">Party 1 &amp; Obligation</th> <th style="text-align: left">Party 2 &amp; Obligation</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">$1M Mortgage between JPM and John Doe</td> <td style="text-align: left">JPM promises to increase John Doe’s checking account by $1M</td> <td style="text-align: left">John Doe promises to pay interest &amp; principal per agreement.</td> </tr> <tr> <td style="text-align: left">Aging parent &amp; child (provocative to showcase the nature of contracts)</td> <td style="text-align: left">Parent promises to bequeath wealth upon passing.</td> <td style="text-align: left">Child promises to take care of parent in advanced years.</td> </tr> </tbody> </table> <hr/> <h3 id="assets-somebodys-liabilities">Assets: Somebody’s liabilities</h3> <p>A contract is simply an exchange of liabilities. However, it creates both an asset and liability for both parties. In fact, <strong>all assets are somebody’s liabilities</strong>.</p> <p>Consider the $1M mortgage example</p> <table> <thead> <tr> <th style="text-align: left">Party</th> <th style="text-align: left">Liability</th> <th style="text-align: left">Asset</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">JP Morgan</td> <td style="text-align: left">Increment John Doe’s checking account by $1M</td> <td style="text-align: left">John Doe’s future interest &amp; principal payments</td> </tr> <tr> <td style="text-align: left">John Doe</td> <td style="text-align: left">Future interest &amp; principal payments</td> <td style="text-align: left">$1M in Checking account</td> </tr> </tbody> </table> <p>As you can see, the contract confers both an asset and a liability to both parties. This is the basis of double-entry book-keeping.</p> <hr/> <h2 id="no-more-circularity">No more circularity</h2> <p>The fundamental unit of the economy is contracts. Something as simple as buying a chair involves a contract. John Doe sends US$ (Fed’s liability) and the manufacturer sends the chair (manufacturer’s liability) with a promise that it will work as advertised. If the chair doesn’t, it perhaps comes with a warranty which is analogous to credit risk in a bond.</p> <p>Most money is just bank credit &amp; it gets created by a bank on demand. For example, when John buys a chair using his credit card, JPM simply creates a liability for John and credits the chair manufacturer’s checking account. No US$ is involved at all.</p> <p>There’s a bit more to this story, including what happens when the chair manufacturer’s account is in BofA &amp; John’s card is JPM - it does involve transferring US$ (so called reserves) from JPM to BofA but in the background.</p> <blockquote class="block-tip"> <p>The economy is NOT dependent on a circular rotation of some limited resource called money, but it progresses via a SEQUENCE of contracts. There’s no confusion on how money’s circulating - it is not going round &amp; round; it is just being created freshly. New contracts (e.g. credit) may be created to service old contracts.</p> </blockquote> <h2 id="illustration-treasury-transfer-payments">Illustration: Treasury Transfer payments</h2> <p>What happens when the Treasury makes transfer payments (i.e. free distributions) to citizens? To a good approximation, this is what happens</p> <ul> <li>The Treasury holds its checking account with the Fed. It’s called TGA (Treasury General Account)</li> <li>Treasury instructs the Fed to transfer $1000 from its TGA to JPM for the benefit of John Doe</li> <li>Fed transfers $1000 from TGA to JPM</li> <li>JPM credits $1000 to John Doe’s checking account</li> </ul> <p>You may have noticed that there are a bunch of uni-directional transfers which contradicts our insistence that each Contract (or Transaction) is an exchange of Liabilities! It turns out that our theory correctly predicts the existence of offsetting liabilities. So, I depict each transaction as an exchange of liabilities. The <em>fictional</em> Goodwill liability of John Doe is quite a standard accounting entity.</p> <blockquote class="block-danger"> <p>Note: This is an approximation to help our understanding. The actual balance sheet entries are likely different.</p> </blockquote> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/Treasury-Transfer-to-John-Doe-Balance-sheet-impact.svg-480.webp"/> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/Treasury-Transfer-to-John-Doe-Balance-sheet-impact.svg-800.webp"/> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/Treasury-Transfer-to-John-Doe-Balance-sheet-impact.svg-1400.webp"/> <img src="/assets/img/Treasury-Transfer-to-John-Doe-Balance-sheet-impact.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="so-whats-money">So, what’s Money?</h1> <p>After that understanding of contracts &amp; liabilities, we can now answer what Money is.</p> <blockquote class="block-tip"> <p>To a good approximation,</p> <ul> <li>Money just includes a subset of liabilities of banks and the Federal Reserve</li> <li>Banks &amp; Fed are special institutions: Banks create new deposit liabilities via loans and Federal Reserve creates US$ liabilities</li> <li>There are different measures of money, M1, M2 etc and they each pick a different subset of bank &amp; Fed liabilities to include. The details are not important for us right now.</li> </ul> </blockquote> <p>Even though banks are special in terms of regulation, banking itself is not. Setting aside regulations,</p> <ul> <li>John Doe can maintain his own ledger of checking accounts like a bank if enough customers believe in his ability to on-demand pay them</li> <li>John Doe can also issue loans (again, just a matter of keeping accounts) if enough people believe in his ability to on-demand pay their checking accounts</li> <li>Banks just happen to be certified institutions and operate under important constraints on how many loans they can dole out among others.</li> </ul> <hr/> <h1 id="outro">Outro</h1> <p>Phew, that was a lot. This section starts with a recap and concludes with some takeaways and follow-up questions.</p> <h2 id="recap">Recap</h2> <p>A quick recap of the entire thought process from beginning to end</p> <ul> <li>I started with the question <code class="language-plaintext highlighter-rouge">What is money?</code></li> <li>To make progress, I asked a strawman question <code class="language-plaintext highlighter-rouge">What happens when John Doe takes a mortgage?</code></li> <li>Even after more than an year of pondering on and off, I couldn’t answer the strawman convincingly</li> <li>Eventually, I added a constraint: any answer to this question must only use symmetric phrases - banning asymmetric phases like give, take, lend, owe, etc.</li> <li>As it turned out, this symmetry constraint unlocked the whole mystery &amp; within a matter of an hour, the primary concepts all became clear</li> </ul> <blockquote class="block-tip"> <h2 id="takeaways">Takeaways</h2> <ul> <li>A Liability is just a promise - everybody can create one, but it acquires value only when it can be exchanged for another liability. This exchange of Liabilities is a Contract. <ul> <li>For every liability, there is a clear <strong>Issuer</strong> and a clear definition of what the liability entails</li> <li>US$ is the Fed’s liability, not the US Govt.’s. Fed is ostensibly an independent entity distinct the US Govt</li> <li>It just so happens that most human contracts (like mortagages) are written in US$; they could also be written in any other liability, like Gold, Bitcoin or JPM Checking Account etc.</li> </ul> </li> <li>Your assets are always somebody else’s liabilities <ul> <li>100 US$ in JPM checking account is not the same as 100 US$ in BofA checking account - they are both liabilities of the respective banks</li> <li>Human knowledge of natural sciences is a fantastic asset because it is mother nature’s liability which she honors in eternity with close to 0 performance risk. Most human contracts are very limited in their time. There’s a risk that humans misunderstood the liability (for e.g. Newton’s laws are inaccurate), but that is not mother nature’s responsibility</li> </ul> </li> <li>Democracy and mass bankruptcy are incompatible <ul> <li>When a large pct of population is unable to honor their contracts (like mortages), Democracy votes (indirectly) for reducing the contract burden</li> <li>Since most contracts are written in US$, cheapening US$ makes it easier to honor the contract</li> <li>Naturally, all Democratic Fiat currencies tend to 0 over time</li> <li>Since they cannot be cheapened on demand, hard currencies like Gold &amp; Bitcoin can force massive bankruptcies &amp; recessions; this appears to be the lived history on the Gold standard.</li> </ul> </li> </ul> </blockquote> <h2 id="follow-up-questions">Follow-up questions</h2> <p>Armed with this knowledge, we can ask a bunch of follow-up questions. We can offer very reasonable answers to these questions but they are posts in their own right.</p> <ul> <li>What is a good economy? <ul> <li>Hint: One that’s confidently entering a lot of contracts!</li> </ul> </li> <li>Is bitcoin better than US$ for the economy? <ul> <li>Hint: Does it help enter more contracts? What happens during a recession - is it good or bad that Fed can print US$?</li> </ul> </li> <li>What is Quantitave Easing? <ul> <li>Is it a good or bad experiment? Hint: QE involves Fed printing US$ and buying US Treasuries and private citizen Mortgage obligations.</li> </ul> </li> <li>Why do most people still talk about money in “lender/receiver” terms when there’s just a contract? <ul> <li>Hint: It is a relic of the Gold standard. Gold was the only money at some point and a loan amounted to transferring Gold from the bank to the person.</li> </ul> </li> <li>Will a Govt. ever pay back its debt? <ul> <li>Hint: No, not in the way a Gold based debt would need to be paid back.</li> </ul> </li> <li>What do analysts mean when they say <code class="language-plaintext highlighter-rouge">cash on the sidelines</code>? <ul> <li>Hint: this is an oxymoron!</li> </ul> </li> </ul>]]></content><author><name></name></author><category term="finance"/><category term="symmetry"/><summary type="html"><![CDATA[Where does money come from? How to understand it? A surprising answer comes from symmetry.]]></summary></entry></feed>