<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Can testing it be objective? Hello from Homomorphisms. | Vemana's Space.</title> <meta name="author" content="Subrahmanyam "> <meta name="description" content="How many tests to write? What tests to write? Can there be objective answers? Surprisingly, the answer is yes for a certain class of programs."> <meta name="keywords" content="software-engineering, math"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://vemana.github.io/blog/2023/testing-calculator-homomorphism/"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Vemana's Space.</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <style type="text/css">.red-text{color:red}</style> <div class="post"> <header class="post-header"> <h1 class="post-title">Can testing it be objective? Hello from Homomorphisms.</h1> <p class="post-meta">October 20, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/software-testing"> <i class="fas fa-hashtag fa-sm"></i> software-testing</a>     ·   <a href="/blog/category/software-engineering"> <i class="fas fa-tag fa-sm"></i> software-engineering</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#5-minute-summary">5 minute summary</a> <ul> <li class="toc-entry toc-h2"><a href="#what-is-a-homomorphic-impl">What is a Homomorphic Impl?</a></li> <li class="toc-entry toc-h2"><a href="#why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl?</a></li> <li class="toc-entry toc-h2"><a href="#summary-of-the-summary">Summary of the summary!</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#introduction">Introduction</a> <ul> <li class="toc-entry toc-h2"><a href="#why-care-about-eliminating-test-subjectivity-and-minimizing-tests">Why care about eliminating test subjectivity and minimizing tests?</a></li> <li class="toc-entry toc-h2"><a href="#in-this-post">In this post…</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#a-surprisingly-robust-strawman">A [surprisingly robust] strawman</a> <ul> <li class="toc-entry toc-h2"><a href="#making-the-question-concrete">Making the question concrete</a></li> <li class="toc-entry toc-h2"><a href="#solution-attempt">Solution Attempt</a></li> <li class="toc-entry toc-h2"><a href="#segmenting-the-tests">Segmenting the tests</a></li> <li class="toc-entry toc-h2"><a href="#this-strawman-is-robust">This strawman is robust!</a></li> <li class="toc-entry toc-h2"><a href="#skip-complex-argument-tests">Skip complex argument tests?</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#slaying-the-strawman">Slaying the strawman</a> <ul> <li class="toc-entry toc-h2"><a href="#dealing-with-arg-depth">Dealing with arg depth</a></li> <li class="toc-entry toc-h2"><a href="#homomorphisms">Homomorphisms</a></li> <li class="toc-entry toc-h2"><a href="#exploiting-homomorphisms">Exploiting Homomorphisms</a></li> </ul> </li> <li class="toc-entry toc-h1"><a href="#conclusion">Conclusion</a></li> </ul> </div> <hr> <div id="markdown-content"> <h1 id="5-minute-summary">5 minute summary</h1> <p>If you ever wrote a test for a piece of code, you’ve wondered how many and what kind of tests to write. Surprisingly, for a class of functions called homomorphisms, you can write minimal tests with confidence. They are also very common if you know to look for them, but that’s a topic for another time.</p> <p>For a calculator <code class="language-plaintext highlighter-rouge">evaluate</code> function:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{...}</span>
</code></pre></div></div> <p>operating on AST</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sealed</span> <span class="kd">interface</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="n">record</span> <span class="nf">Addition</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Division</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Number</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Variable</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>with example expression</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a*10 + b // a &amp; b are variables whose values can be looked up in VariableMap
</code></pre></div></div> <p>Don’t write it like this (let’s give it a name: <strong>Natural Impl</strong>):</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">variables</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">+</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">*</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">/</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
  <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <p>Write it like this instead (let’s give it a name: <strong>Homomorphic impl</strong> for reasons explained later):</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Since the thrust of this post is testing, we'll not comment on </span>
<span class="c1">// 1. Efficiency. For example, boxing, varargs overheads here. </span>
<span class="c1">//    There are many ways to mitigate them.</span>
<span class="c1">// 2. Error handling. What if dividing by 0? </span>
<span class="c1">//    Again, there are many options.</span>

<span class="kd">interface</span> <span class="nc">Operator</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="nf">invoke</span><span class="o">(</span><span class="kt">long</span><span class="o">...</span> <span class="n">children</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Evaluator</span> <span class="o">{</span>
  
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">PLUS</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">MULTIPLY</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">DIVIDE</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]/</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

  <span class="c1">// This is our evaluate function implementation</span>
  <span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
        <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="nf">operator</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">varMap</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">PLUS</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">MULTIPLY</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">DIVIDE</span><span class="o">;</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Expression</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>and write the following basic tests:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// One basics test per Node (like Addition, Multiplication)
expect(7, "a", {a = 7}); // Variable
expect(9, "9", {});      // Number
expect(11, "1+10", {});  // Addition
expect(12, "3*4", {});   // Multiplication
expect(2, "4/2", {});    // Division

// One test per Corner case per Node
expect_failure("1/0", {});
</code></pre></div></div> <p>but skip more complex tests like this (we can prove they are not required):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Complex tests (arg depth &gt; 1): can be skipped with Homomorphic Impl
expect(203, "10*20+a", {a=3});
expect(18, "a*b+(3*2)", {a=3, b=4});
</code></pre></div></div> <p>thereby obtaining full coverage in a small number of tests.</p> <h2 id="what-is-a-homomorphic-impl">What is a Homomorphic Impl?</h2> <p>Homomorphic Impl exploits the fact that the <code class="language-plaintext highlighter-rouge">evaluate</code> function is a <strong>Homomorphism</strong> <a href="https://en.wikipedia.org/wiki/Homomorphism" rel="external nofollow noopener" target="_blank">(wiki)</a> to separate tree traversal from operator application. Despite the math terminology, Homomorphism <a href="#homomorphisms">(in layman terms)</a> is a simple idea.</p> <p>In a Homomorphic Impl, each node defines its <strong>Operator</strong> function (PLUS, MULTIPLY etc.) and there’s a separate evaluator that traverses the Expression tree and invokes the Operators. Contrast this with the <strong>Natural Impl</strong> where the traversal is intertwined with the Operator application in the body of the method impl. This sort of coupling doesn’t age well - see <a href="#why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl</a>.</p> <h2 id="why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl?</h2> <p>There are many benefits to exploiting homomorphism.</p> <p><strong>Test minimalism</strong></p> <ul> <li>With a Homomorphic Impl, <strong>you can confidently skip complex tests</strong> - like those that use arg depths &gt; 1. <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>// Complex tests (arg depth &gt; 1): can be skipped with Homomorphic Impl
expect(203, "10*20+a", {a=3});
expect(18, "a*b+(3*2)", {a=3, b=4});
</code></pre></div> </div> </li> <li>We can prove rigorously that they are not needed; but it is fine to write one single complex expression test, just to be safe</li> </ul> <p><strong>Ageable code</strong>. Homomorphic Impl ages well along many important dimensions of change.</p> <ul> <li>Introduce parallelism easily if required. Doing this with Natural Impl gets very messy very quick <div class="language-java highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// Showing only the changed parts.</span>

<span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">try</span><span class="o">(</span><span class="kt">var</span> <span class="n">scope</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StructuredTaskScope</span><span class="o">.</span><span class="na">ShutdownOnFailure</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nf">evaluate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">,</span> <span class="nc">StructuredTaskScope</span> <span class="n">scope</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">var</span> <span class="n">childResults</span> <span class="o">=</span> <span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                         <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">scope</span><span class="o">.</span><span class="na">fork</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)))</span>
                         <span class="o">.</span><span class="na">toList</span><span class="o">();</span>
  <span class="n">scope</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
  <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
      <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">childResults</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                  <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Future:</span><span class="o">:</span><span class="n">resultNow</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
<span class="o">}</span>
</code></pre></div> </div> </li> <li>Homomorphic Impl has O(1) calls to <code class="language-plaintext highlighter-rouge">evaluate</code> but Natural Impl has O(Nodes) calls to <code class="language-plaintext highlighter-rouge">evaluate</code> <ul> <li>In the example above, Homomorphic Impl has 1 call to <code class="language-plaintext highlighter-rouge">evaluate</code> while Natural Impl has 6 of them (2 each for addition, multiplication, division operators)</li> <li>Reducing usage of API surface is extremely useful in practice. <ul> <li>For example, consider changing the API signature to pass one more parameter. It requires 2 changes in Homomorphic Impl but 6 changes in Natural Impl. This adds up quickly when you have 20 Operators instead of 5</li> <li>Not applicable here, but instrumenting call-sites for telemetry is easier when you have fewer number of call-sites</li> </ul> </li> </ul> </li> <li>Add new operators with ease <ul> <li>For example, it is trivial to add the SUBTRACTION operator</li> <li>Code remains easy to read even with 20 operators, while the Natural Impl starts becoming unwieldy at say 10</li> </ul> </li> <li>Handoffs to different owners are relatively straightforward to explain</li> </ul> <h2 id="summary-of-the-summary">Summary of the summary!</h2> <p>There’s a class of functions called Homomorphisms that can be coded in a certain pattern - the Homomorphic Impl - which requires only a small number of tests to gain confidence. The pattern also ages well to many typical changes. Homomorphisms are VERY common if you know to look for them, but that’s an entirely different post.</p> <hr> <h1 id="introduction">Introduction</h1> <p>All good quality Software has tests. But, there’s the age old question faced by every software engineer:</p> <ul> <li>How many tests should I write?</li> <li>What kind of tests should I write?</li> </ul> <p>These are good questions that elicit non-committal, <strong>it depends</strong> answers that ultimately don’t help either the author, the code reviewer or the next maintainer.</p> <h2 id="why-care-about-eliminating-test-subjectivity-and-minimizing-tests">Why care about eliminating test subjectivity and minimizing tests?</h2> <p>High quality automated tests are essential for high quality software. Tests determine iteration &amp; in turn product velocity. A lack of tests is a disaster in the making - any project of reasonable size grinds to a crawl without automated tests while their presence avoids <code class="language-plaintext highlighter-rouge">hostage to the code</code> situations. Rapid changes can be made &amp; rolled out with confidence.</p> <p>Test minimalism is important because a large number of tests (for e.g. to obtain code coverage) carries significant costs - presubmit times balloon, tests tend to get coupled with code &amp; changes to one piece of code breaks a large number of tests for no good reason.</p> <p>Test subjectivity - that is, what tests to write - hinders productivity. It causes code review debates, missing tests (because there’s no framework to think about them) which bite later, difficulty in understanding which new tests to write when changing code, challenges in handovers to a different owners among others.</p> <p>There are plenty of other concerns that are topics for other posts. For example, once you decide to write a test (logically), how to write it cleanly in a way that conveys the intent of the test to any new maintainer? Really the list is endless; one can barely scratch the surface of quality tests with a single post.</p> <blockquote class="block-warning"> <p>Perhaps the most important thing going for quality tests is this funnel: quality tests -&gt; higher productivity -&gt; less need to hire a ton -&gt; less need to reduce the hiring bar -&gt; maintain high revenue/employee -&gt; happier employees -&gt; growth for everyone.</p> </blockquote> <h2 id="in-this-post">In this post…</h2> <blockquote class="block-tip"> <p>In this post, I’ll demonstrate a class of problems &amp; a strategy of coding for which we CAN objectively write a minimal number of tests with confidence &amp; coverage.</p> </blockquote> <p>Testing is such a complex subject that it is likely not feasible to provide a general recommendation. At the same time, there are probably some problem domains which admit objective recommendations. In more than a decade of engineering experience, I am yet to encounter objective recommendations for what &amp; how many tests to write. It is not even clear if such recommendations exist. But, in this post I argue otherwise and make an object recommendation on a particular problem domain.</p> <p>One might ask: how feasible is it to have one objective recommendation per problem domain that admits? It is a whole lot better than the current mess of general recommendations which mean different things to different people. As a field, current best practices around tests seem ambigous and fresh thoughts with more objectivity are necessary.</p> <hr> <h1 id="a-surprisingly-robust-strawman">A [surprisingly robust] strawman</h1> <p>How to approach a daunting, nebulous question like <code class="language-plaintext highlighter-rouge">What kind of tests should I write?</code>? Start by asking a simpler, almost strawman question, of course!</p> <blockquote class="block-warning"> <p><strong>A simpler, natural question to ask</strong>: What is the minimal number of tests one needs to write for a Calculator program?</p> </blockquote> <h2 id="making-the-question-concrete">Making the question concrete</h2> <p>Let’s make it concrete by defining an Expression AST. The Calculator program operates on this AST.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Calculator program Expression AST</span>

<span class="n">sealed</span> <span class="kd">interface</span> <span class="nc">Expression</span> <span class="o">{</span>
  <span class="n">record</span> <span class="nf">Addition</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Division</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">left</span><span class="o">,</span> <span class="nc">Expression</span> <span class="n">right</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Number</span><span class="o">(</span><span class="kt">long</span> <span class="n">value</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
  <span class="n">record</span> <span class="nf">Variable</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">implements</span> <span class="nc">Expression</span> <span class="o">{}</span>
<span class="o">}</span>
</code></pre></div></div> <p>Some example <code class="language-plaintext highlighter-rouge">Expression</code>s include <code class="language-plaintext highlighter-rouge">(a*10+b)/100</code> which corresponds to a AST that looks like:</p> <ul> <li>Division <ul> <li>Addition <ul> <li>Multiplication <ul> <li>Variable(“a”)</li> <li>Number(10)</li> </ul> </li> <li>Variable(“b”)</li> </ul> </li> <li>Number(100)</li> </ul> </li> </ul> <p>So, now we are ready to restate the question.</p> <blockquote class="block-warning"> <p><strong>Concrete strawman question</strong>: How to write a Calculator program where:</p> <ul> <li>The program implements a function <code class="language-plaintext highlighter-rouge">long evaluate(Expression input, VariableMap variables);</code> that evaluates the expression</li> <li>The program should be accompanied by tests</li> <li>The tests should give confidence that the implementation works</li> <li>The number of tests should be minimal</li> </ul> </blockquote> <h2 id="solution-attempt">Solution Attempt</h2> <p>It is natural to write a solution that looks like this:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">input</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">variables</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">value</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">variables</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">+</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">*</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
    <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">variables</span><span class="o">)</span> <span class="o">/</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">variables</span><span class="o">);</span>
  <span class="o">};</span>
<span class="o">}</span>
</code></pre></div></div> <p>And follow it up with tests like</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>expect(11, "a+10", {a=1});
expect(12, "a*b", {a=3, b=4});
expect(203, "10*20+3", {});
</code></pre></div></div> <p>So far so good. But, the question remains: what tests to write &amp; how many of them to write. For example, are the following tests necessary?</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. expect(18, "a*b+(3*2)", {a=3, b=4});
2. expect_failure("a/b", {a=1, b=0});
3. expect_failure(10 + 12/b, {b=0});
</code></pre></div></div> <p>Each of these tests ostensibly tests something. #1 appears to test a complex expression, #2 appears to test a corner case, #3 appears to combine them both (corner case within a complex expression). The challenge is to be able to objectively say that a given number of tests are sufficient.</p> <h2 id="segmenting-the-tests">Segmenting the tests</h2> <p>After some reflection, it is natural to arrive at a segmentation of tests:</p> <table> <thead> <tr> <th style="text-align: left">Test Id &amp; Description</th> <th style="text-align: left">Examples <br> Format: <strong>Test Name: Example</strong> </th> <th style="text-align: left">Count</th> </tr> </thead> <tbody> <tr> <td style="text-align: left"> <strong>[Per-node basic]</strong>. <br> One basics test per Node type. The arguments have depth 1. <br> Node can be Addition, Variable, Multiplication, Number, Division</td> <td style="text-align: left">Addition basic: <code class="language-plaintext highlighter-rouge">expect(11, 10+1, {})</code> <br>Multiplication basic: <code class="language-plaintext highlighter-rouge">expect(20, 10*2, {})</code> </td> <td style="text-align: left">O(#Nodes)</td> </tr> <tr> <td style="text-align: left"> <strong>[Per-node corner case]</strong>. <br> One test per corner case per node.</td> <td style="text-align: left">Division corner case: <code class="language-plaintext highlighter-rouge">expect_failure("1/0",{})</code> </td> <td style="text-align: left">O(#Nodes)</td> </tr> <tr> <td style="text-align: left"> <strong>[Complex arguments]</strong>. <br> One test involving a complex expression, potentially involving all the operators</td> <td style="text-align: left">Complex arguments: <code class="language-plaintext highlighter-rouge">expect(5, 1*2+9/a, {a=3})</code> </td> <td style="text-align: left">O(1), but unclear whether &amp; which ones to write</td> </tr> <tr> <td style="text-align: left"> <strong>[Per-node Complex arguments]</strong>. <br> One complex expression test per Node type</td> <td style="text-align: left">Addition complex arguments: <code class="language-plaintext highlighter-rouge">expect(22, 1*2+10*(1*2), {})</code> <br> Multiplication complex arguments: <code class="language-plaintext highlighter-rouge">expect(15, (1+2)*(2+3), {})</code> </td> <td style="text-align: left">O(#Nodes). Unclear whether to writes and if so, which ones to write</td> </tr> <tr> <td style="text-align: left"> <strong>[Per-node Complex arguments arg depth = K]</strong>. <br> One complex arguments test per Node type. At least one of the arguments has a depth K.</td> <td style="text-align: left">Addition complex arguments, arg depth=3: <code class="language-plaintext highlighter-rouge">expect(29, 1*2*3*4 + 5, {})</code> </td> <td style="text-align: left">O(#Nodes). Unclear whether such tests should be written &amp; if so, what arg-depths are acceptable</td> </tr> </tbody> </table> <p><br> In practice, different styles differ on whether to write <strong>[Per-node Complex arguments]</strong> test and what values of <code class="language-plaintext highlighter-rouge">K</code> are considered acceptable for <strong>[Per-node complex arguments, arg depth=K]</strong> tests.</p> <h2 id="this-strawman-is-robust">This strawman is robust!</h2> <p>Even this simple example of a Calculator demonstrates the inherent difficulty in deciding which tests to write.</p> <ul> <li>Without a meaningful segmentation of tests, we cannot answer whether there’s sufficient coverage and obtain confidence in the implementation.</li> <li>Even with a segmentation, it is unclear which test to write for each segment</li> </ul> <p>Segmentation is reasonable progress but we still haven’t answered which tests to write and why those tests give us confidence in the implementation.</p> <h2 id="skip-complex-argument-tests">Skip complex argument tests?</h2> <p>One might argue that complex arguments tests are not required because the code is recursively evaluating each child first and only passing its result to the parent operator. So, the complexity of the child argument is immaterial. This is certainly a reasonable argument &amp; in fact, one this post will make towards the conclusion. But, there are some important reasons to continue investigating further:</p> <ul> <li>[Special code structure] The testing strategy of skipping complex arguments is only valid when child evaluation results are passed to the parent <ul> <li>When a code base is touched by many people, this requirement can easily get lost</li> <li>Often, at the point when the original author moves on, the code has this structure but no one else knows that it has that structure</li> </ul> </li> <li>[Node complexity and cardinality] Even if all the code base authors are familiar with the code structure, a large number of node types and/or complex node evaluations can make it hard to maintain the structure <ul> <li>In the above example, we had 5 node types. In industrial strength applications - for e.g. translating a user query to sql - this factor can be more than 20</li> <li>Once we get above a few pages worth of the <code class="language-plaintext highlighter-rouge">evaluate</code> function, we’ll need tools to help ensure that we are always evaluating the children recursively before applying the parent’s operator</li> </ul> </li> </ul> <p>If only we had some tools to help us maintain the structure! Then, we can simply skip the complex argument tests with confidence.</p> <hr> <h1 id="slaying-the-strawman">Slaying the strawman</h1> <p>How do we make progress? The primary cause of test subjectivity is the arg-depth of complex argument tests. We don’t know if a particular bug will be triggered only on arg depths of &gt;= 2 and in a particular traversal path through the Expression tree. So, it is reasonable to never fully feel confident that our code works for all possible depths while only testing a sample of depth 2.</p> <h2 id="dealing-with-arg-depth">Dealing with arg depth</h2> <blockquote> <p>One way to grapple with the arg depth question is to somehow make the arg depth immaterial i.e. complex argument tests will catch the same bugs regardless of arg depth.</p> </blockquote> <p>Let’s assume we can make arg-depth immaterial. What does it buy us? For a start, we can simply pick arg depth = 1. <code class="language-plaintext highlighter-rouge">Once we set arg depth = 1, [Per-node complex arguments arg depth = 1] is the same set of tests as [Per-node basic] tests. Remarkably, we can drop the complex argument tests w/o missing any coverage!</code> This is a sizeable reduction in the set of tests and contributes to the goal of reducing the number of tests.</p> <p>That’s promising. How do we make arg-depth immaterial? arg depth being immaterial means that the bugs found from arbitrary depths (ignore stack overflow) are the same bugs found at arg depth = 1. This suggests that the implementation function for a Node should not even have access to the child Nodes - if it did, the impl can become intricately dependent on the exact arg and a bug might be triggered on only a very specific tree <code class="language-plaintext highlighter-rouge">(Addition(Multiplication(Division)))</code> say and we wouldn’t know to test this particular tree. That is a bummer because <code class="language-plaintext highlighter-rouge">how can we implement the function if it can't even access the child Nodes?</code></p> <p>Perhaps surprisingly, there is a way to approach this. But first we need a detour in homomorphisms.</p> <h2 id="homomorphisms">Homomorphisms</h2> <p><a href="https://en.wikipedia.org/wiki/Homomorphism" rel="external nofollow noopener" target="_blank">Homomorphism</a> is an algebraic construct which essentially captures the following idea:</p> <blockquote class="block-tip"> <p><strong>Homomorphism in layman terms</strong> <br> <br></p> <p>Consider a function which evaluates Nodes in a Tree (or directed acyclic graph more generally)</p> <ul> <li>Example: functions like those in the strawman question: <code class="language-plaintext highlighter-rouge">long evaluate(Expression node, VariableMap vars)</code> </li> <li>Such a function is either a homomorphism or not.</li> </ul> <p>It is a homomorphism if it has the following characteristics (to a good approximation)</p> <ul> <li>Each Node has a bunch of [possibly empty] child Nodes <ul> <li>Example: <code class="language-plaintext highlighter-rouge">Addition</code> Node has two children while <code class="language-plaintext highlighter-rouge">Number</code> Node has no children</li> </ul> </li> <li>Each Node type has a corresponding operator function <ul> <li>E.g. <code class="language-plaintext highlighter-rouge">SUM</code> is the operator function for <code class="language-plaintext highlighter-rouge">Addition</code> node, and <code class="language-plaintext highlighter-rouge">MULTIPLY</code> is the operator function for <code class="language-plaintext highlighter-rouge">Multiplication</code> node</li> <li>Note that this operator function cannot depend on the Node’s children. That is, Addition node will always have the same operator (<code class="language-plaintext highlighter-rouge">SUM</code>) regardless of its arguments.</li> <li>The operator function for a Node <code class="language-plaintext highlighter-rouge">Number(v)</code> is the zero-ary operator <code class="language-plaintext highlighter-rouge">v</code>; i.e. it’s a function which takes no arguments and always returns <code class="language-plaintext highlighter-rouge">v</code>. This is in contrast to the binary <code class="language-plaintext highlighter-rouge">SUM</code> function. In both cases, the Operator function is independent of children. Note that <code class="language-plaintext highlighter-rouge">v</code> is not a child of <code class="language-plaintext highlighter-rouge">Number(v)</code>, it is a configuration parameter, if you will.</li> </ul> </li> <li>The function’s evaluation of a Node is equivalent to applying the node’s operator function to the evaluated values of each of its children <ul> <li>That is, <code class="language-plaintext highlighter-rouge">Evaluate(Node(node params, child1, child2, ...)) := Node.operator(node params)(Evaluate(child1, child2, ..))</code> </li> <li>That is, <code class="language-plaintext highlighter-rouge">Evaluate(Addition(left, right)) := SUM(Evaluate(left), Evaluate(right))</code> </li> <li>Similarly, <code class="language-plaintext highlighter-rouge">Evaluate(Number(value)) := value() == value</code> </li> </ul> </li> </ul> </blockquote> <h2 id="exploiting-homomorphisms">Exploiting Homomorphisms</h2> <p>Let’s start by noting that our Calculator’s <code class="language-plaintext highlighter-rouge">evaluate</code> function is a homomorphism.</p> <p>So what, you ask? Why do we care about Homomorphisms?</p> <ul> <li>Homomorphism has so much structure that it can be factored further</li> <li>Further factoring means we get to invoke one of the foundational principles of software engineering: separation of concerns</li> <li>The factors (aka concerns) are relatively straightforward too <ul> <li>Evaluating child Nodes</li> <li>Invoking the Node’s operator passing child node values as arguments</li> </ul> </li> <li>We can structure our code into two orthogonal pieces, one for each of the factors <ul> <li>Tests can be written for each of those orthogonal pieces <ul> <li>Tests that the correct Operator (like SUM) is being invoked with correct arguments</li> <li>Tests for each of the Operators</li> </ul> </li> <li>Alternatively, tests can be written just for publicly visible piece (the <code class="language-plaintext highlighter-rouge">evaluate</code> function) <ul> <li>This implicitly tests that the correct Operator is being invoked with the correct arguments</li> </ul> </li> </ul> </li> </ul> <p><strong>Code structure after separating the factors: Evaluating child nodes &amp; Invoking node operators</strong></p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// Since the thrust of this post is testing, we'll not comment on </span>
<span class="c1">// 1. Efficiency. For example, boxing, varargs overheads here. </span>
<span class="c1">//    There are many ways to mitigate them.</span>
<span class="c1">// 2. Error handling. What if dividing by 0? </span>
<span class="c1">//    Again, there are many options.</span>

<span class="kd">interface</span> <span class="nc">Operator</span> <span class="o">{</span>
  <span class="kt">long</span> <span class="nf">invoke</span><span class="o">(</span><span class="kt">long</span><span class="o">...</span> <span class="n">children</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Evaluator</span> <span class="o">{</span>
  
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">PLUS</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">MULTIPLY</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]*</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Operator</span> <span class="no">DIVIDE</span> <span class="o">=</span> <span class="n">vals</span> <span class="o">-&gt;</span> <span class="n">vals</span><span class="o">[</span><span class="mi">0</span><span class="o">]/</span><span class="n">vals</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

  <span class="c1">// This is our evaluate function implementation</span>
  <span class="kd">static</span> <span class="kt">long</span> <span class="nf">evaluate</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">operator</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">varMap</span><span class="o">)</span>
        <span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">children</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">child</span> <span class="o">-&gt;</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">varMap</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">mapToLong</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
                    <span class="o">.</span><span class="na">toArray</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="nf">operator</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">,</span> <span class="nc">VariableMap</span> <span class="n">varMap</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">v</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">_</span> <span class="o">-&gt;</span> <span class="n">varMap</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">PLUS</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">MULTIPLY</span><span class="o">;</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">_</span><span class="o">,</span> <span class="n">_</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="no">DIVIDE</span><span class="o">;</span>
    <span class="o">};</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">static</span> <span class="nc">Stream</span><span class="o">&lt;</span><span class="nc">Expression</span><span class="o">&gt;</span> <span class="nf">children</span><span class="o">(</span><span class="nc">Expression</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">switch</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nf">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Variable</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">();</span> <span class="c1">// empty</span>
      <span class="k">case</span> <span class="nf">Addition</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Multiplication</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
      <span class="k">case</span> <span class="nf">Division</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">Stream</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">);</span>
    <span class="o">};</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p><br></p> <p>With this structure, let’s examine the tests again</p> <ul> <li> <strong>Per-node basic</strong> tests are required</li> <li> <strong>Per-node corner case</strong> tests are required</li> <li>All other tests (e.g. complex arguments) can be skipped</li> </ul> <p>In particular, all other complex argument tests can be skipped. This is because composition is triggered even for the simplest evaluations. At this point, it is reasonable to ask: is this additional code worth it? isn’t it the same thing as the original attempt - just that the code is inline? Isn’t the original attempt more compact &amp; readable? All of these are legitimate questions that are answered in <a href="#why-prefer-a-homomorphic-impl">Why prefer a Homomorphic Impl</a>.</p> <h1 id="conclusion">Conclusion</h1> <p>See <a href="#summary-of-the-summary">Summary of the Summary</a>.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/money-from-symmetry/">What is Money? Where does it come from? An answer from symmetry.</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Subrahmanyam . </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>